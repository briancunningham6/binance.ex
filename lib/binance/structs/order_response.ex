defmodule Binance.Structs.OrderResponse do
  @moduledoc """
  Response tructure for POST /api/v3/order endpoint.
  All prices and quantities are string representation of floats with 8 decimals (eg: "orig_qty": "10.00000000")
  """

  alias Binance.Structs.FillOrder

  defstruct [
    :client_order_id,
    :executed_qty,
    :order_id,
    :orig_qty,
    :price,
    :side,
    :status,
    :symbol,
    :time_in_force,
    :transact_time,
    :type,
    :fills
  ]

  use ExConstructor

  @doc """
  Overrides default `new/2` function generated by ExConstructor to parse the sub-struct :fills if it exists.
  """
  @spec new(ExConstructor.map_or_kwlist, Keyword.t) :: %__MODULE__{}
  def new(map_or_kwlist, opts \\ []) do
    ExConstructor.populate_struct(%__MODULE__{}, map_or_kwlist, Keyword.merge(@exconstructor_default_options, opts))
    |> Map.replace_lazy(:fills, fn x -> x && Enum.map(x, &FillOrder.new/1) end)
  end

  @typedoc """
  side: "BUY" | "SELL"
  """
  @type side :: String.t()

  @typedoc """
  status: "NEW" | "PARTIALLY_FILLED" | "FILLED" | "CANCELED" | "PENDING_CANCEL" | "REJECTED"Â | "EXPIRED"
  """
  @type status :: String.t()

  @typedoc """
  type: "LIMIT" | "MARKET" | "STOP" | "STOP_MARKET" | "TAKE_PROFIT" | "TAKE_PROFIT_MARKET" | "LIMIT_MAKER"
  """
  @type type :: String.t()

  @type t :: %__MODULE__{
          client_order_id: String.t(),
          executed_qty: String.t(),
          order_id: non_neg_integer(),
          orig_qty: String.t(),
          price: String.t(),
          side: side(),
          status: status(),
          symbol: String.t(),
          time_in_force: non_neg_integer(),
          transact_time: non_neg_integer(),
          type: type(),
          fills: [FillOrder] | nil
        }
end
